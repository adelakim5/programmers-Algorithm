## 합승 택시 요금

> 프로그래머스 레벨3, 카카오

### 풀이

- 다익스트라 알고리즘을 사용하였다.
  > 플로이드워셜로도 풀 수 있다.

1. s에서 모든 정점까지 갈 수 있는 최단 거리를 구한다.
   - 이를 위해, 2차원 배열의 그래프를 만든다.
     - `fares`에 들어있는 정보들을 바탕으로 각 정점들 간의 비용을 가진 그래프를 만든다.
     - 단, `graph[i][i] = 0`. 자기 자신으로 향하는 비용은 0이기 때문이다.
     - 직접 연결되지 않은 정점들은 `Infinity`값으로 둔다.
   - 최소힙을 사용한다.
   - 다익스트라 알고리즘으로 s에서 시작하는 각 정점들의 최단거리를 구한다.
     - 참고자료 [다익스트라 알고리즘 - 바킹독님](https://blog.encrypted.gg/918?category=773649)
2. a, b에서 모든 정점까지 갈 수 있는 최단 거리를 각각 구한다.
   - 방법은 위와 동일하다.
3. 비용의 최솟값을 구한다.
   - 택시 요금 계산의 경우의 수는 다음과 같다.
   1. a, b가 따로따로 택시탄다.
   2. a, b가 일정 지점만큼 함께가고, 그 다음부터는 각자 따로 간다.
   - 따라서, 최솟값 비교는 다음과 같이 할 수 있다.
   ```js
   // s_d: s에서 모든 정점까지 가는 최단거리 값을 가진 배열
   // a_d: a에서 모든 정점까지 가는 최단거리 값을 가진 배열
   // b_d: b에서 모든 정점까지 가는 최단거리 값을 가진 배열
   costIndividual = s_d[a] + s_d[b]; // s -> a까지 가는 값 + s -> b까지 가는 값
   costTogethers = [
                       s_d[1] + a_d[1] + b_d[1], // s -> 1까지 가는 값 + 1 -> a까지 가는 값 + 1 -> b까지 가는 값
                       s_d[2] + a_d[2] + b_d[2],
                       s_d[3] + a_d[3] + b_d[3],
                       ...
                   ]
   const minValue = Math.min(costIndividual, ...costTogethers) // 모든 비용 중 가장 최솟값
   ```
4. 최솟값을 리턴한다.

#### 시행착오

1. a, b가 합승하는 부분을 다르게 구현해서 시간초과가 났었다.
   - a, b 모두 연결된 정점을 구한 다음, `s -> 연결된 정점 -> a, b` 이런식으로 구하려고 했다.
   - 그래서 2차원배열 그래프를 만드는 부분에서 reduce를 사용해 a, b 모두 연결된 정점들을 저장하고, for문으로 돌면서 `s -> 해당 정점들의 거리`를 구한 후 a, b까지의 거리를 더하는 방식으로 진행했다.
   - 하지만 실패했고... 시간은 흐르고 나는 점점 피곤해져서... 검색의 도움을 받았다.
