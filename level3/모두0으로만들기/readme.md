## 모두 0으로 만들기

> 프로그래머스 레벨 3

### 풀이

a의 합이 0이 되지 않는다면 -1을 리턴한다.

0이 되면, 모든 점들의 가중치를 0으로 만들 수 있으므로, 리프노드부터 루트노드로 흐르며 노드의 가중치를 0으로 만들어나간다.

1. 트리를 구성한다.

- 각 정점별로 연결된 정점을 구한다.
- 이차원 배열에 저장한다.

```js
edges = [
  [0, 1],
  [3, 4],
  [2, 3],
  [0, 3],
];
tree = [
  // vertex: 0 -> 0과 연결된 점들
  [1, 3],
  // vertex: 1 -> 1과 연결된 점들
  [0],
  // ...
  [3],
  [4, 2, 0],
  [3],
];
```

2. 리프노드부터 부모로 dfs로 탐색하며 가중치를 합산한다.
   📌 a의 길이가 최대 300,000이기 때문에 재귀로 돌리면 콜스택이 터져 런타임 에러가 난다.

- stack에 루트 노드를 넣는다.
  - 트리는 어떤 정점을 기준으로 잡아도 트리기 때문에 쉽게 0을 넣었다.
  - 현재 정점과 해당 정점의 부모값을 함께 넣는다.
  - 루트 노드의 경우 부모를 `null`로 두었다.
- 방문 체크할 visited 배열을 만든다.
  - 초기값은 모두 false로 둔다.
- stack에 값이 있는 동안

  1. stack의 가장 마지막 정점을 방문한다.
  2. 방문한 정점은 visited를 true로 바꾼다.
  3. 스택에 방문한 현재 정점과 현재 정점의 부모 정점을 스택에 넣는다.
  4. 현재 정점과 연결된 정점 중 방문하지 않은 정점을 스택에 넣는다.

  - 이 정점은 현재 정점의 자식이라고 볼 수 있다.
  - 부모 정점을 현재 정점으로 하여 스택에 넣는다.

  > 🚩 그런데 스택의 가장 마지막 정점이 이미 방문한 정점이면 ? 👉 리프 노드!
  >
  > 리프 노드와 연결된 정점들을 모두 이미 방문했다면, 그건 리프 노드의 부모 노드를 모두 방문했다는 의미이고, 더이상 자식이 없다는 의미기 때문이다.

  5. 스택의 가장 마지막 정점이 이미 방문한 정점이면, 현재 정점의 가중치를 부모의 가중치에 합산한다.

  - 또한 절댓값을 answer에 합산한다.
  - answer은 **BigInt**로 계산해주어야 한다.

3. answer을 반환한다.
