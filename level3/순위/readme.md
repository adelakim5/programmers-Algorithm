## 순위

> 프로그래머스 레벨 3

### 풀이

1. 이차원 배열을 만든다.
   - 모든 값을 `Infinity`로 초기화한다.
   - 행과 열이 같은 값은 0으로 처리한다.
2. 이기고 진 관계에 따라 값을 다르게 처리해준다.
   - 각 행을 선수의 번호라고 생각하고
   - ex. `[4, 3]`의 경우
     - 4번째 행의 3번째 열에 -1을 적는다(`g[4][3] = -1`): 3이 4한테 졌기 때문
     - 3번째 행의 4번째 열에 1을 적는다(`g[3][4] = 1`): 4가 3을 이겼기 때문
3. 이차원 배열 내 값들을 갱신한다.
   - 나에게 진 선수에게 진 선수들은 모두 다 나에게 진 것이므로, 해당 번호에 맞는 열의 값을 -1로 갱신해야 한다.
   - 나에게 이긴 선수를 이긴 선수들은 모두 다 나를 이긴 것이므로, 해당 번호에 맞는 열의 값을 1로 갱신해야 한다.
   - **플로이드워셜**로 푼다.
     1. 이차원 배열의 각 행(`i`, 현재 나)을 돌면서
     2. 다른 선수(`j`)와 또다른 선수(`k`)의 관계를 알 수 없을 떄(`g[j][k] === Infinity`)
     3. 내가 `j`를 이겼고 && `k`가 나를 이겼다면 `k`는 `j`를 이기게 된다 (`g[j][i] === 1 && g[i][k] === 1 ? g[j][k] = 1`).
     4. 내가 `j`에게 졌고 && `k`가 나에게 졌다면 `k`는 `j`에게 지게 된다 (`g[j][i] === -1 && g[i][k] === -1 ? g[j][k] = -1`).
     5. 위 과정을 `i`가 이차원배열 마지막 행까지 다 돌동안 반복한다.
4. 이차원 배열 내 값을 체크한다.
   - 각 행에 `Infinity`값이 남아있다면 ? 관계를 알 수 없다, 즉 순위를 알 수 없는 선수이다.
   - 따라서 `Infinity` 값이 없을 때에만 answer를 증가시킨다.
5. answer를 반환한다.
