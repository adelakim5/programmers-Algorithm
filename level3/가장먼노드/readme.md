## 가장 먼 노드
> 프로그래머스 레벨 3

### 풀이 
1. 인접리스트를 만든다. 
   - 각 정점마다 연결된 정점을 모아둔 인접리스트를 만든다. 
   - 예를 들면
    ```
    1 => [3, 2]
    2 => [3, 1, 4, 5]
    3 => [6, 4, 2, 1]
    4 => [3, 2]
    5 => [2]
    6 => [3]
    ```
2. bfs로 탐색한다. 
   1. 방문여부를 체크할 배열을 만든다. 
   2. 큐를 만든다. 
   3. 1과 인접한 정점을 가져온다. 
   4. 1과 인접한 정점들을 
      - 방문하고
      - 간선의 길이를 1로 세팅하고
      - 이 정점이 1로부터 1만큼 떨어져있다고 저장한다. 
        - 이를 위해 `array` 배열을 만들었다. 
   5. 1과 인접한 정점들을 큐에 넣는다. 
   6. 큐가 빌때까지 
      1. 큐에서 꺼낸 첫번째 원소와 인접한 정점들을 가져온다. 
      2. 이 인접한 정점들 중 **방문하지 않은** 정점인 경우에만 큐에 넣는다. 
      3. 방문했다고 표시해준다. 
      4. 간선의 길이를 +1 해준다. 
      5. `array`배열의 정점 인덱스 자리에 +1 해준 간선의 길이를 저장한다.
      6. 위 과정을 반복한다.
      7. 반복하는 중간마다 **간선의 길이가 최댓값인지** 확인한다. 
   7. 최댓값과 `array` 배열을 반환한다. 
3. 반환된 `array`에서 최댓값과 같은 값이 몇개인지 세어준다. 
4. 세어준 개수를 반환한다.  

#### 📌 새로 알게된 팁
- reduce를 이용하여 인접리스트를 만든다. 
  - 나는 좀.. rough한 방식으로 풀었다. 
  - Map을 생성해서 key, value를 set해주는 방식으로 풀었다. 
  - 그래서 edge들의 각 값들이 Map의 key로 존재하는지 아닌지 확인해주고, 이에 따라 value를 세팅해주었는데, 훨씬 간결하게 만드는 방법을 발견!
